import axios from "axios";
import { Readable } from "stream";
import AsyncRetry from "async-retry";
// GraphQL query builder class, uses overload signatures to modify class generics to provide concise typings for any configured query
// this approach does mean (atm anyway) we need to explicitly coerce return types to the correct "shape", but as most of the methods are dynamic, this isn't much of an issue.
// TODO: look into constructor facade pattern - https://gist.github.com/kourge/9715e0dd59c28e776fb598d407636106
// TODO: look into https://discord.com/channels/508357248330760243/1122523559097548870
/**
 * GraphQL query class - encapsulates all logic, types, and methods required to resolve queries
 */
export class GraphQLQuery {
    /* implements BuilderMethods<TVars, GraphQLQuery<TQuery, TVars, TReturn>> */
    // query variables
    queryVars = {};
    // query fields
    queryFields;
    // query metadata
    queryInfo;
    // query string, payload sent to node
    _query;
    // url of the node to query
    url;
    // misc operational config
    config;
    // result tracker object, used to hold state for paging operations
    resultTracker = { numPages: 0, numResults: 0, done: false };
    constructor({ url, retryConfig, query, queryName, opts, }) {
        if (!url)
            throw new Error("URL is required");
        this.url = new URL(url);
        this.config = {
            first: false,
            userProvided: false,
            numPages: Infinity,
            numResults: 1_000,
            retryOpts: { retries: 3, maxTimeout: 2_000, minTimeout: 500, ...retryConfig },
        };
        if (query === false)
            return this;
        if (!query)
            throw new Error(`Unable to find query with name ${queryName}`);
        this.queryInfo = { ...query };
        this.queryFields = query.query;
        if (queryName.includes("arweave") && this.url.host === "node1.bundlr.network")
            this.url = new URL("https://arweave.net/graphql");
        if (!opts?.skipVariableSetters) {
            // generate dynamic variable setter builder methods
            for (const k of Object.keys(query.vars)) {
                if (this[k])
                    throw new Error(`Field setter ${k} has a key conflict - disable with opts.skipVariableSetters OR change the field name and add to query.remapVars`);
                this[k] = (value) => {
                    this.queryVars[k] = value;
                    return this;
                };
            }
        }
        return this;
    }
    /**
     * Builds a query from fields and variables, formatting it into a GQL compatible string.
     * stores built query under `this.query` (protected) - accessible via `.toQuery`
     * @returns `this` (chainable)
     */
    buildQuery() {
        // @ts-expect-error overloading
        if (this.config.userProvided)
            return this; // don't build if it's a user provided query string
        // builds query, reducing `this.queryFields` to a structured string with correct formatting
        const toGQLString = (s) => JSON.stringify(s, (_, v) => {
            if (v instanceof Array)
                return v[0]; /* JSON.stringify(v); */
            if (typeof v === "object")
                return v;
            if (v === false)
                return undefined;
            return "";
        })
            .replaceAll(`:`, "")
            .replaceAll(`"`, "")
            .replaceAll(",", "\n          ");
        const nodeQuery = toGQLString(this.queryFields);
        // the hasNextPage field can vary
        const pageInfo = toGQLString({ pageInfo: { [this.queryInfo.paging?.hasNextPage ?? "hasNextPage"]: undefined } }).slice(1, -1); // remove leading "{" and finishing "}"
        const enumValues = this.queryInfo.enumValues;
        // incorporates defaults from queryInfo
        const vars = { ...this.queryInfo.vars, ...this.queryVars };
        // remap keys - primarily done to prevent conflicts with builder methods.
        // {limit: "first"} -> remaps `limit` variable to `first` variable
        // {limit: (k,v) => ["first",v]} does the same thing
        for (const [k, v] of Object.entries(this.queryInfo.remapVars ?? {})) {
            if (vars?.[k] === undefined)
                continue;
            if (typeof v === "function") {
                // provided mapper fn
                const m = v(k, vars[k], vars);
                if (!m)
                    continue;
                const [nk, nv] = m;
                vars[nk] = nv;
                if (nk === k)
                    continue; // don't null out key if it's the same key
            }
            else {
                vars[v] = vars[k];
            }
            vars[k] = undefined; // null keys are removed below
        }
        // reduces queryVars to inline vars, for convenience. (using separate means we have to annotate the GQL type)
        const qVars = JSON.stringify(vars, function (k, v) {
            // console.log(this, k, v);
            if (v === undefined)
                return v; // remove null keys
            if (v instanceof Array)
                return v; // don't break recursion
            if (typeof v === "object")
                return v; // ^
            if (typeof v === "number")
                return v; // numbers don't need string escaping
            // TODO: improve this so it's context aware and doesn't alter anything unintentional
            // can probably do by logging key names into array if value is an object, popping when object is a primitive
            if (enumValues?.includes(k))
                return v; // exclude enum variants from quote addition
            return `'${v}'`; // this value needs to be quote padded
        })
            .replaceAll('"', "") // remove double quotes,
            .replaceAll("'", '"') // add needed double quotes
            .slice(1, -1); // remove leading "{" and finishing "}"
        if (!this?.queryInfo?.name)
            throw new Error(`Query name is undefined!`);
        // discriminate based on whether the query is pageable
        const query = this.queryInfo.paging
            ? `query {
      ${this.queryInfo.name}(
        ${qVars}
      ) {
        edges {
          cursor
          node ${nodeQuery}
        }
        ${pageInfo}
      }
    }`
            : `query {
    ${this.queryInfo.name}(
      ${qVars}
    ) 
    ${nodeQuery}
  }`;
        this._query = query;
        // @ts-expect-error types - DO NOT SET RETURN TYPE TO `this` - TS will assume this should be an async function as `this` implements promise methods
        return this;
    }
    /**
     * Primary query execution method - builds & runs the query, returning result nodes and updating cursor info in queryVars
     * @returns query result nodes
     */
    async getPage() {
        if (this.resultTracker.done)
            return undefined;
        this.buildQuery();
        if (!this._query)
            throw new Error(`Unable to run undefined query`);
        let res;
        try {
            res = await AsyncRetry(async (_) => {
                const r = await axios(this.url.toString(), {
                    method: "post",
                    headers: { "Content-Type": "application/json" },
                    data: { query: this._query },
                });
                if (r.data.errors)
                    throw r;
                return r;
            }, this.config.retryOpts);
        }
        catch (e) {
            throw new Error(`Error running query\n ${this._query} - ${e.message ? e.message + " -" : ""} (${JSON.stringify(e?.data?.errors.map((e) => e.message) ?? e?.errors ?? e)}) `);
        }
        if (this.config.userProvided)
            return this.trimmer([res.data.data].flat(20));
        const data = res.data.data[this.queryInfo.name];
        // if this is a pageable query if this is defined
        if (this.queryInfo.paging) {
            const nextCursor = data.pageInfo[this.queryInfo.paging.hasNextPage] ? data.edges.at(-1)[this.queryInfo.paging.cursor] : undefined;
            this.queryVars.after = nextCursor;
            return this.trimmer(data.edges.map((v) => v.node));
        }
        return this.trimmer([data].flat(20));
    }
    // tracks & controls output
    trimmer(res) {
        const numPages = ++this.resultTracker.numPages;
        const numResults = (this.resultTracker.numResults += res.length);
        if (res.length === 0) {
            this.resultTracker.done = true;
            return res;
        }
        if (numPages >= this?.config?.numPages)
            this.resultTracker.done = true;
        if (numResults >= this?.config?.numResults) {
            this.resultTracker.done = true;
            const delta = this.config.numResults - (numResults - res.length);
            return res.slice(0, delta);
        }
        return res;
    }
    // return modifier functions
    /**
     * Get the first result from the query
     * @returns the first result from the query - gets at maximum one page
     */
    async first() {
        const res = await this.getPage();
        return res?.at(0) ?? undefined;
    }
    /**
     * Limiter on the number of pages a given query should resolve to
     * @param numPages Maximum number of pages to return
     * @returns this (chainable)
     */
    maxPages(numPages) {
        this.config.numPages = numPages;
        // @ts-expect-error types
        return this;
    }
    /**
     * Limiter on the maximum number of results a given query should resolve to
     * @param numResults Maximum number of results to return
     * @returns this (chainable)
     */
    limit(numResults) {
        this.config.numResults = numResults;
        // @ts-expect-error types
        return this;
    }
    // return functions
    /**
     * Gets all results from the built query
     * @returns array of results
     */
    async all() {
        const results = [];
        do {
            const page = await this.getPage();
            if (!page)
                break;
            // @ts-expect-error types
            results.push(...page);
        } while (this.queryVars.after);
        return results;
    }
    /**
     * Async generator, yields individual query result items
     */
    async *generator() {
        do {
            const res = await this.getPage();
            if (!res)
                return;
            // @ts-expect-error constraints
            for (const r of res)
                yield r;
        } while (this.queryVars.after); // getPage sets after to undefined if there are no more pages
    }
    /**
     * Readable stream produced from `this.generator`
     * @returns a readable instance, with the "data" event yielding individual results
     */
    stream() {
        return Readable.from(this.generator());
    }
    /**
     * Provide a custom query string to resolve
     * @param query Query string to use
     * @returns result of the query - this method does not support paging or extraction
     */
    query(query) {
        this._query = query;
        this.config.userProvided = true;
        // @ts-expect-error overloading
        return this;
    }
    // TODO issue: this allows for additional (top level only?!) fields that aren't part of TQuery - for now we perform JS level shape checks and throw.
    /**
     * Set the fields you want the query to return
     * @param fields - Object structured like a graphql query body, truthy values including, falsy excluding
     * @param skipFieldCheck - whether to skip JS level fields object shape validation
     * @returns `this` (chainable)
     */
    fields(fields, skipFieldCheck = false) {
        // validate provided fields against default fields
        // default/allowed fields is under `this.queryFields`
        // user selected fields are under `fields`
        // path, allowed, user provided - it's flat so we don't need super precise comparision
        const recursiveValidate = (p, a, b) => {
            for (const k of Object.keys(b)) {
                let ak = a[k];
                if (Array.isArray(ak))
                    ak = ak[0];
                const bk = b[k];
                if (ak === undefined)
                    throw new Error(`Illegal field ${p}${k}`);
                if (typeof bk === "object")
                    recursiveValidate(p + k + ".", ak, bk);
            }
        };
        if (!skipFieldCheck)
            recursiveValidate("", this.queryFields, fields);
        this.queryFields = fields;
        // @ts-expect-error TODO: fix this
        return this;
    }
    /**
     * Sets variables/filters using an object
     * @param variables variable object to set
     * @returns this (chainable)
     */
    variables(variables) {
        this.queryVars = { ...this.queryVars, ...variables };
        // @ts-expect-error - dynamic builder props
        return this;
    }
    /**
     * Builds the current query and returns a ready to POST query string
     * @returns string form of the current query
     */
    async toQuery() {
        await this.buildQuery();
        return this._query;
    }
    // instance generic type accessors
    /**
     * Dummy method to access the internal `TReturn` generic type
     * @returns "tReturn"
     */
    tReturn() {
        return "tReturn";
    }
    /**
     * Dummy method to access the internal `TQuery` generic type
     * @returns "tQuery"
     */
    tQuery() {
        return "tQuery";
    }
    /**
     * Dummy method to access the internal `TVars` generic type
     * @returns "tVars"
     */
    tVars() {
        return "tVars";
    }
    // Promise contract functions, so users can `await` a GraphQLQuery instance to resolve the built query.
    // very cool, thanks Knex.
    /**
     * Resolves `this` by getting all results for the query (including paging)
     * @param onFulfilled - optional onFulfilled callback
     * @returns - all results for built query
     */
    async then(onFulfilled, onRejected) {
        const res = this.all();
        return res.then(onFulfilled, onRejected);
    }
    async catch(onReject) {
        return this.then().catch(onReject);
    }
    async finally(onFinally) {
        return this.then().finally(onFinally);
    }
}
// this was definitely not over engineered ðŸ‘€
//# sourceMappingURL=graphql.js.map