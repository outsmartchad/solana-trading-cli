/// <reference types="node" />
import { Readable } from "stream";
import type { ArrayElement, BuilderMethods, Field, QueryInfo, ReturnFields, SearchOpts } from "./types.js";
import type { Options as RetryOptions } from "async-retry";
/**
 * GraphQL query class - encapsulates all logic, types, and methods required to resolve queries
 */
export declare class GraphQLQuery<TQuery extends Record<any, any> = any, TVars extends Record<string, any> = any, TReturn extends Record<string, any> = any> {
    protected queryVars: Record<string, any>;
    protected queryFields: Record<string, any>;
    protected queryInfo: QueryInfo & {
        name: string;
    };
    protected _query: string | undefined;
    protected url: URL;
    protected config: {
        first: boolean;
        userProvided: boolean;
        numPages: number;
        numResults: number;
        retryOpts?: RetryOptions;
    };
    protected resultTracker: {
        numResults: number;
        numPages: number;
        done: boolean;
    };
    constructor({ url, retryConfig, query, queryName, opts, }: {
        url: string | URL;
        retryConfig?: RetryOptions;
        query?: QueryInfo | false;
        queryName: string;
        opts?: SearchOpts;
    });
    /**
     * Builds a query from fields and variables, formatting it into a GQL compatible string.
     * stores built query under `this.query` (protected) - accessible via `.toQuery`
     * @returns `this` (chainable)
     */
    protected buildQuery(): BuilderMethods<TVars, GraphQLQuery<TQuery, TVars, TReturn>>;
    /**
     * Primary query execution method - builds & runs the query, returning result nodes and updating cursor info in queryVars
     * @returns query result nodes
     */
    getPage(): Promise<TReturn | undefined>;
    private trimmer;
    /**
     * Get the first result from the query
     * @returns the first result from the query - gets at maximum one page
     */
    first(): Promise<ArrayElement<TReturn>>;
    /**
     * Limiter on the number of pages a given query should resolve to
     * @param numPages Maximum number of pages to return
     * @returns this (chainable)
     */
    protected maxPages(numPages: number): BuilderMethods<TVars, GraphQLQuery<TQuery, TVars, TReturn>>;
    /**
     * Limiter on the maximum number of results a given query should resolve to
     * @param numResults Maximum number of results to return
     * @returns this (chainable)
     */
    limit(numResults: number): BuilderMethods<TVars, GraphQLQuery<TQuery, TVars, TReturn>>;
    /**
     * Gets all results from the built query
     * @returns array of results
     */
    protected all(): Promise<TReturn>;
    /**
     * Async generator, yields individual query result items
     */
    protected generator(): AsyncGenerator<Required<ArrayElement<TReturn>>>;
    /**
     * Readable stream produced from `this.generator`
     * @returns a readable instance, with the "data" event yielding individual results
     */
    stream(): {
        on(event: "data", listener: (res: ArrayElement<TReturn>) => any): any;
    } & Readable;
    /**
     * Provide a custom query string to resolve
     * @param query Query string to use
     * @returns result of the query - this method does not support paging or extraction
     */
    query<T extends TReturn = TReturn>(query: string): GraphQLQuery<TQuery, TVars, T>;
    /**
     * Set the fields you want the query to return
     * @param fields - Object structured like a graphql query body, truthy values including, falsy excluding
     * @param skipFieldCheck - whether to skip JS level fields object shape validation
     * @returns `this` (chainable)
     */
    fields<T extends Field<TQuery> = Field<TQuery>>(fields: T, skipFieldCheck?: boolean): BuilderMethods<TVars, GraphQLQuery<TQuery, TVars, ReturnFields<TQuery, T>[]>>;
    /**
     * Sets variables/filters using an object
     * @param variables variable object to set
     * @returns this (chainable)
     */
    variables(variables: Partial<TVars> & any): BuilderMethods<TVars, GraphQLQuery<TQuery, TVars, TReturn>>;
    /**
     * Builds the current query and returns a ready to POST query string
     * @returns string form of the current query
     */
    toQuery(): Promise<string>;
    /**
     * Dummy method to access the internal `TReturn` generic type
     * @returns "tReturn"
     */
    protected tReturn(): TReturn;
    /**
     * Dummy method to access the internal `TQuery` generic type
     * @returns "tQuery"
     */
    protected tQuery(): TQuery;
    /**
     * Dummy method to access the internal `TVars` generic type
     * @returns "tVars"
     */
    protected tVars(): TVars;
    /**
     * Resolves `this` by getting all results for the query (including paging)
     * @param onFulfilled - optional onFulfilled callback
     * @returns - all results for built query
     */
    then(onFulfilled?: ((value: TReturn) => any | PromiseLike<TReturn>) | undefined | null, onRejected?: (value: Error) => any | PromiseLike<Error> | undefined | null): Promise<TReturn | never>;
    catch(onReject?: ((value: TReturn) => any | PromiseLike<TReturn>) | undefined | null): Promise<null>;
    finally(onFinally?: (() => void) | null | undefined): Promise<TReturn | null>;
}
