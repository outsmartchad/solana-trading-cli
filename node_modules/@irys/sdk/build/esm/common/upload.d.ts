/// <reference types="node" />
/// <reference types="node" />
import type { DataItem, JWKInterface } from "arbundles/node";
import type { AxiosResponse } from "axios";
import type { Readable } from "stream";
import type Api from "./api.js";
import { ChunkingUploader } from "./chunkingUploader.js";
import type { Token, Arbundles, IrysTransactonCtor, UploadOptions, UploadReceipt, UploadResponse, CreateAndUploadOptions, Manifest } from "./types.js";
import type Utils from "./utils.js";
export declare const sleep: (ms: number) => Promise<void>;
export declare const CHUNKING_THRESHOLD = 50000000;
export default class Uploader {
    protected readonly api: Api;
    protected token: string;
    protected tokenConfig: Token;
    protected utils: Utils;
    protected contentTypeOverride: string | undefined;
    protected forceUseChunking: boolean | undefined;
    protected arbundles: Arbundles;
    protected irysTransaction: IrysTransactonCtor;
    constructor(api: Api, utils: Utils, token: string, tokenConfig: Token, irysTransaction: IrysTransactonCtor);
    /**
     * Uploads a given transaction to the bundler
     * @param transaction
     */
    uploadTransaction(transaction: DataItem | Readable | Buffer, opts: UploadOptions & {
        getReceiptSignature: true;
    }): Promise<AxiosResponse<UploadReceipt>>;
    uploadTransaction(transaction: DataItem | Readable | Buffer, opts?: UploadOptions): Promise<AxiosResponse<UploadResponse>>;
    uploadData(data: string | Buffer | Readable, opts?: CreateAndUploadOptions): Promise<UploadResponse>;
    concurrentUploader(data: (DataItem | Buffer | Readable)[], opts?: {
        concurrency?: number;
        resultProcessor?: (res: any) => Promise<any>;
        logFunction?: (log: string) => Promise<any>;
        itemOptions?: CreateAndUploadOptions;
    }): Promise<{
        errors: any[];
        results: any[];
    }>;
    protected processItem(data: string | Buffer | Readable | DataItem, opts?: CreateAndUploadOptions): Promise<any>;
    /**
     * geneates a manifest JSON object
     * @param config.items mapping of logical paths to item IDs
     * @param config.indexFile optional logical path of the index file for the manifest
     * @returns
     */
    generateManifest(config: {
        items: Map<string, string>;
        indexFile?: string;
    }): Promise<Manifest>;
    get chunkedUploader(): ChunkingUploader;
    set useChunking(state: boolean);
    set contentType(type: string);
    /**
     * Creates & Uploads a [nested bundle](https://docs.bundlr.network/faqs/dev-faq#what-is-a-nested-bundle) from the provided list of transactions. \
     * NOTE: If a provided transaction is unsigned, the transaction is signed using a temporary (throwaway) Arweave key. \
     * This means transactions can be associated with a single "random" address. \
     * NOTE: If a Buffer is provided, it is converted into a transaction and then signed by the throwaway key. \
     * The throwaway key, address, and all bundled (provided + throwaway signed + generated) transactions are returned by this method.
     *
     * @param transactions List of transactions (DataItems/Raw data buffers) to bundle
     * @param opts Standard upload options, plus the `throwawayKey` paramter, for passing your own throwaway JWK
     * @returns Standard upload response from the bundler node, plus the throwaway key & address, and the list of bundled transactions
     */
    uploadBundle(transactions: (DataItem | Buffer | string)[], opts: UploadOptions & {
        getReceiptSignature: true;
        throwawayKey?: JWKInterface;
    }): Promise<AxiosResponse<UploadReceipt> & {
        throwawayKey: JWKInterface;
        throwawayKeyAddress: string;
        txs: DataItem[];
    }>;
    uploadBundle(transactions: (DataItem | Buffer)[], opts?: UploadOptions & {
        throwawayKey?: JWKInterface;
    }): Promise<AxiosResponse<UploadResponse> & {
        throwawayKey: JWKInterface;
        throwawayKeyAddress: string;
        txs: DataItem[];
    }>;
}
