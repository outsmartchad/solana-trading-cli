/// <reference types="node" />
import type BigNumber from "bignumber.js";
import type { DataItem, Signer, createData, deepHash, getCryptoDriver, stringToBuffer, DataItemCreateOptions, bundleAndSignData } from "arbundles";
import type { FileDataItem } from "arbundles/file";
import type Irys from "./irys.js";
export type CreateTxData = {
    amount: BigNumber.Value;
    to: string;
    fee?: string;
};
export interface Arbundles {
    createData: typeof createData;
    DataItem: typeof DataItem;
    deepHash: typeof deepHash;
    stringToBuffer: typeof stringToBuffer;
    getCryptoDriver: typeof getCryptoDriver;
    bundleAndSignData: typeof bundleAndSignData;
}
export interface IrysTransaction extends DataItem {
    sign: () => Promise<Buffer>;
    size: number;
    uploadWithReceipt: (opts?: UploadOptions) => Promise<UploadReceipt>;
    upload(opts: UploadOptions & {
        getReceiptSignature: true;
    }): Promise<UploadReceipt>;
    upload(opts?: UploadOptions): Promise<UploadResponse>;
    isValid(): Promise<boolean>;
}
export type IrysTransactonCtor = new (data: string | Uint8Array, Irys: Pick<Irys, "uploader" | "tokenConfig" | "arbundles">, opts?: IrysTransactionCreateOptions) => IrysTransaction;
export interface Tx {
    from: string;
    to: string;
    amount: BigNumber;
    blockHeight?: BigNumber;
    pending: boolean;
    confirmed: boolean;
}
export interface TokenConfig {
    irys: Irys;
    name: string;
    ticker: string;
    minConfirm?: number;
    wallet?: string | object;
    providerUrl: string;
    isSlow?: boolean;
    opts?: any;
}
export interface IrysConfig {
    timeout?: number;
    providerUrl?: string;
    contractAddress?: string;
    tokenOpts?: object;
    headers?: Record<string, string>;
}
export interface Token {
    isSlow: boolean;
    needsFee: boolean;
    base: [string, number];
    name: string;
    get address(): string | undefined;
    ticker: string;
    irys: Irys;
    getTx(txId: string): Promise<Tx>;
    ownerToAddress(owner: any): string;
    getId(item: FileDataItem): Promise<string>;
    price(): Promise<number>;
    sign(data: Uint8Array): Promise<Uint8Array>;
    getSigner(): Signer;
    verify(pub: any, data: Uint8Array, signature: Uint8Array): Promise<boolean>;
    getCurrentHeight(): Promise<BigNumber>;
    getFee(amount: BigNumber.Value, to?: string): Promise<BigNumber | object>;
    sendTx(data: any): Promise<string | undefined>;
    createTx(amount: BigNumber.Value, to: string, fee?: string | object): Promise<{
        txId: string | undefined;
        tx: any;
    }>;
    getPublicKey(): Promise<string | Buffer> | (string | Buffer);
    ready?(): Promise<void>;
}
export interface Manifest {
    manifest: string;
    version: string;
    paths: Record<string, Record<string, Record<"id", string>>>;
    index?: Record<"path", string>;
}
export interface UploadResponse {
    id: string;
    public: string;
    signature: string;
    deadlineHeight: number;
    validatorSignatures: {
        address: string;
        signature: string;
    }[];
    timestamp: number;
    version: "1.0.0";
    verify: () => Promise<boolean>;
}
export type UploadReceipt = UploadResponse;
export type UploadReceiptData = Omit<UploadReceipt, "verify">;
export interface FundResponse {
    reward: string;
    target: string;
    quantity: string;
    id: string;
}
export interface WithdrawalResponse {
    tx_id: string;
    requested: number;
    fee: number;
    final: number;
}
export type CreateAndUploadOptions = DataItemCreateOptions & {
    upload?: UploadOptions;
};
export interface UploadOptions {
}
export type IrysTransactionCreateOptions = DataItemCreateOptions & {
    dataIsRawTransaction?: boolean;
};
export type HashingAlgo = "sha256" | "sha384";
export type ProvenanceProof = {
    dataProtocol: "Provenance-Confirmation" | string;
    hashingAlgo?: HashingAlgo | string;
    dataHash: string;
    uploadedFor?: string;
    prompt?: string;
    promptHash?: string;
    model?: string;
};
export type TxGqlNode = {
    id: string;
    receipt: {
        deadlineHeight: number;
        signature: string;
        timestamp: number;
        version: string;
    };
    tags: {
        name: string;
        value: string;
    }[];
    address: string;
    currency: string;
    signature: string;
    timetamp: number;
};
export type TxGqlResponse = {
    data: {
        transactions: {
            edges: {
                node: TxGqlNode;
            }[];
            pageInfo?: {
                endCursor: string | null;
                hasNextPage: boolean;
            };
        };
    };
};
